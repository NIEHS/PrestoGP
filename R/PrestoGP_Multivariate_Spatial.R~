#' Title
#'
#' @slot model PrestoGPModel.
#'
#' @export MultivariateSpatialModel
#'
#' @examples
#' @include PrestoGP_Model.R
#' @noRd
MultivariateSpatialModel <- setClass("MultivariateSpatialModel",
                                    contains = "PrestoGPModel",
                                    slots = c(
                                      model = "PrestoGPModel",
                                      param_sequence = "matrix",
                                      logparams = "numeric"
                                    ))

validityMultivariateSpatialModel<-function(object){
  TRUE
}
setValidity("MultivariateSpatialModel", validityMultivariateSpatialModel)

setMethod("initialize", "MultivariateSpatialModel", function(.Object, ...) {
  .Object@n_neighbors <- 0#25
  .Object@min_m <- 0
  .Object <- callNextMethod()
  validObject(.Object)
  .Object
})

#' Make predictions using a previously fit spatiotemporal model.
#'
#' @param model A model object returned by prestogp_fit.
#' @param X Independent variable matrix for prediction.
#' @param locs Locations matrix for which the value is predicted.
#'
#' @return predicted values for the dependent variable
#' @export
#'
#' @examples
#'
#' ...
#' model <- SpatiotemporalModel()
#' model <- prestogp_fit(model, logNO2, X, locs)
#' prediction <- prestogp_predict(model, X.test, locs.test)
#' Vec.mean <- prediction[[1]]
#' Vec.sds <- prediction[[2]]
setMethod("prestogp_predict", "MultivariateSpatialModel", function(model, X, locs) {
  #validate parameters
  if(!is.matrix(X)){
    stop("X parameter must be a matrix.")
  }
  if(!is.matrix(locs)){
    stop("The locs parameter must be a matrix.")
  }
  if(nrow(X) != nrow(locs)){
    stop("The number of locations must match the number of X observations.")
  }
  if(ncol(locs) != 2){
    stop("The locs parameter must have 2 columns.")
  }

  # Vecchia prediction at new locations
  #Vecchia.Pred <- predict(model@Vecchia_SCAD_fit[[1]], X = X, which = model@lambda_1se_idx[[1]])
  Vecchia.Pred <- predict(model@linear_model, newx = X, s=model@linear_model$lambda[model@lambda_1se_idx])
  dim(Vecchia.Pred) <- c(dim(Vecchia.Pred)[1], dim(Vecchia.Pred)[2])
  # Vecchia trend prediction at observed data
  #Vecchia.hat <- predict(model@Vecchia_SCAD_fit[[1]], X = model@X_train, which = model@lambda_1se_idx[[1]])
  Vecchia.hat <- predict(model@linear_model, newx = model@X_train, s=model@linear_model$lambda[model@lambda_1se_idx])
  dim(Vecchia.hat) <- c(dim(Vecchia.hat)[1], dim(Vecchia.hat)[2])

  # Test set prediction
  #Y_reshaped <-  model@Y_train
  #dim(Y_reshaped) <- c(dim(model@Y_train), 1)
  res = model@Y_train - Vecchia.hat

  locs.train.scaled = scale_locs(model, model@locs_train)
  locs.scaled = scale_locs(model, locs)
  vec.approx.test = vecchia_specify(locs.train.scaled, nrow(model@X_train)-1, locs.pred=locs.scaled)

  ## carry out prediction
  pred = vecchia_prediction(res, vec.approx.test, c(model@covparams[1], 1, 0.5), model@covparams[4])
  #prediction function can return both mean and sds
  # returns a list with elements mu.pred,mu.obs,var.pred,var.obs,V.ord
  Vec.mean = pred$mu.pred + Vecchia.Pred #residual + mean trend
  #option to include or exclude theta below
  Vec.sds = sqrt(pred$var.pred + model@covparams[4]) #standard deviation

  return(list("means" = Vec.mean, "standard deviations" = Vec.sds))
})

setMethod("calc_covparams", "MultivariateSpatialModel", function(model, locs, Y) {
  #cor.matrix <- cor(Y)
  #P <- ncol(Y)
  #col.vars <- apply(Y, 2, var)
  #N <- length(Y)
    P <- length(Y)
    col.vars <- rep(NA, P)
    D.sample.bar <- rep(NA, P)
    for (i in 1:P) {
        col.vars[i] <- var(Y[[i]])
        N <- length(Y[[i]])
        #TODO find a better way to compute initial spatial range
        d.sample <- sample(1:N,max(2, ceiling(N/50)),replace = FALSE)
        D.sample = rdist(locs[[i]][d.sample,1:2])
        D.sample.bar[i] <- mean(D.sample)/4
    }
  model@logparams <- create.initial.values.flex(c(0.9*col.vars), #marginal variance
                                               D.sample.bar, #range
                                               rep(0.5,P), #smoothness
                                               c(.1*col.vars), #nuggets
                                               rep(0, choose(P,2)),
                                               P)
  model@param_sequence <- create.param.sequence(P)
  model <- transform_covariance_parameters(model)
  invisible(model)
})

setMethod("specify", "MultivariateSpatialModel", function(model, locs, m) {
#  locs.scaled = scale_locs(model, locs)
  model@vecchia_approx=vecchia_Mspecify(locs,m)
  invisible(model)
})

#setMethod("scale_locs", "MultivariateSpatialModel", function(model, locs) {
  #FIXME scale locs for this model
#  locs
#})

setMethod("compute_residuals", "MultivariateSpatialModel", function(model, Y, Y.hat) {
#  dim(Y.hat) <- c(nrow(model@Y_train), ncol(model@Y_train))
  model@res = as.double(Y-Y.hat)
  model@vecchia_approx$zord = model@res[model@vecchia_approx$ord]
  invisible(model)
})

setMethod("estimate_theta", "MultivariateSpatialModel", function(model, locs, optim.control, method) {
  P <- length(locs)
#  locs_list <- list()
#  for(i in 1:P){
#    locs_list[[i]] <- locs
#  }
  vecchia.result<- optim(par = model@logparams,
                         fn = mvnegloglik,
                         vecchia.approx=model@vecchia_approx,
                         y = model@res,
                         P = P,
                         param.seq = model@param_sequence,
                         method = method,
                         control=optim.control)
  model@LL_Vecchia_krig <- vecchia.result$value
  model@logparams <- vecchia.result$par
  model <- transform_covariance_parameters(model)
  invisible(model)
})

setMethod("transform_covariance_parameters", "MultivariateSpatialModel", function(model) {
  P <- length(model@Y_train)
  if(P > 1){
      model@covparams <- c(exp(model@logparams[1:model@param_sequence[2,2]]),
                           gtools::inv.logit(model@logparams[model@param_sequence[3,1]:
                                                   model@param_sequence[3,2]],
                                         0,2.5),
                           exp(model@logparams[model@param_sequence[4,1]:
                                               model@param_sequence[4,2]]),
                           tanh(model@logparams[model@param_sequence[5,1]:
                                                model@param_sequence[5,2]]))
  } else {
      model@covparams <- c(exp(model@logparams[1:model@param_sequence[2,2]]),
                           gtools::inv.logit(model@logparams[model@param_sequence[3,1]:
                                                   model@param_sequence[3,2]],
                                         0,2.5),
                           exp(model@logparams[model@param_sequence[4,1]:
                                               model@param_sequence[4,2]]),1)
  }
  invisible(model)
})

setMethod("transform_data", "MultivariateSpatialModel", function(model, Y, X) {
   transformed.data=transform_miid(cbind(Y,as.matrix(X)),
                                   vecchia.approx = model@vecchia_approx,
                                   model@covparams)
   xcols <- ncol(model@X_train)
   ycols <- ncol(model@Y_train)
   tcols <- ncol(transformed.data)
   model@y_tilde <- Matrix(transformed.data[,1:ncol(model@Y_train)])
   model@X_tilde <- Matrix(transformed.data[,(ncol(model@Y_train)+1):ncol(transformed.data)])
   invisible(model)
})

#setMethod("transform_data", "MultivariateSpatialModel", function(model, Y, X) {
  #TODO this should be replaced with sparse inverse Choleksy methods in the new multivariate (CreateU) file
#  n <- nrow(model@Y_train)
#  Sigma.oo <- model@covparams[1]*Exponential(rdist(model@locs_train), range=model@covparams[2])+model@covparams[3]*diag(n)
#  Omega.lc <- solve(t(chol(Sigma.oo)))
#  model@y_tilde <- Matrix(Omega.lc %*% Y)
#  model@X_tilde <- Matrix(Omega.lc %*% X)
#  invisible(model)
#})
# setMethod("transform_data", "MultivariateSpatialModel", function(model, Y, X) {
#   P <- ncol(model@Y_train)
#   seq <- create.param.sequence(P)
#   sigma_parts <- list()
#   for(i in 1:P){ #compute diagonal
#     theta_row <- model@covparams[((i-1)*ncol(model@Y_train)+1):(i*ncol(model@Y_train))]
#     #d11 <- fields::rdist(expand.grid(space.dim/ranges[1],space.dim/ranges[1], time.dim/ranges[2]))
#     #Sigma.oo <- theta_row[1]*Exponential(rdist(model@locs_train), range=theta_row[2])+theta_row[3]*diag(n)
#     Sigma <- marg.var[1] * fields::Matern(d11,range = 1, smoothness = marg.smoothness[1])
#     cat(theta_row, "\n")
#   }
#   invisible(model)
# })

setMethod("theta_names", "MultivariateSpatialModel", function(model) {
  c("Marginal Variance", "Range", "Smoothness", "Nugget")
})
