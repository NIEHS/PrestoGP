% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PrestoGP_Model.R
\name{prestogp_fit,PrestoGPModel-method}
\alias{prestogp_fit,PrestoGPModel-method}
\alias{prestogp_fit}
\title{Train a PrestoGP model.}
\usage{
\S4method{prestogp_fit}{PrestoGPModel}(
  model,
  Y,
  X,
  locs,
  Y.names = NULL,
  X.names = NULL,
  scaling = NULL,
  common_scale = NULL,
  covparams = NULL,
  beta.hat = NULL,
  tol = 0.999999,
  max_iters = 100,
  center.y = NULL,
  impute.y = FALSE,
  lod = NULL,
  quiet = FALSE,
  verbose = FALSE,
  optim.method = "Nelder-Mead",
  optim.control = list(trace = 0, reltol = 0.001, maxit = 5000),
  penalty = c("lasso", "relaxed", "MCP", "SCAD"),
  alpha = 1,
  family = c("gaussian", "binomial"),
  nfolds = 10,
  foldid = NULL,
  parallel = FALSE,
  cluster = NULL,
  adaptive = FALSE
)
}
\arguments{
\item{model}{The PrestoGP model object being fit.}

\item{Y}{The values of the response variable(s). Should be a matrix or
vector for univariate models or a list for multivariate models.}

\item{X}{The values of the predictor variable(s). Should be a matrix for
univariate models or a list for multivariate models.}

\item{locs}{The values of the locations. Should be a matrix for univariate
models or a list for multivariate models.}

\item{Y.names}{The name(s) for the response variable(s). Should be a vector
with length equal to the number of response variables. Defaults to NULL.}

\item{X.names}{The names for the predictor variables. Should be a vector
for univariate models or a list for multivariate models.}

\item{scaling}{A vector of consecutive positive integers that is used to
specify which columns of locs should have the same scaling parameter. For
example, in a spatiotemporal model with two spatial measures and a time
measure, the value of scaling would be c(1, 1, 2). The length of scaling
must match the number of columns of locs. If it is not specified, all
columns of locs will have a common scale parameter.}

\item{common_scale}{Do all columsn of locs have a common scales parameter?
See Details for the effects of this parameter. Defaults to TRUE if there
is only one scale parameter for each outcome and FALSE otherwise.}

\item{covparams}{The initial covariance parameters estimate (optional).}

\item{beta.hat}{The initial beta parameters estimates (optional).}

\item{tol}{The model is considered converged when error is not less than
tol*previous_error (optional). Defaults to 0.999999.}

\item{max_iters}{Maximum number of iterations for the model fitting
procedure. Defaults to 100.}

\item{center.y}{Should the Y's be mean centered before fitting the model?
Defaults to TRUE for gaussian models and FALSE for binomial models.}

\item{impute.y}{Should missing Y's be imputed? Defaults to FALSE.}

\item{lod}{Limit of detection value(s). Any Y value less than lod is
assumed to be missing when performing missing data imputation. Should be
numeric for univariate models and a list for multivariate models, where
each element of the list corresponds to an outcome. The ith element of
the lod is the limit of detection for observation i. Alternatively, one
can specify a single limit of detection that is assumed to be the same for
all observations. If not specified, it is assumed that no limit of
detection exists. Ignored if impute.y is FALSE.}

\item{quiet}{If FALSE, the penalized log likelihood and the model MSE
will be printed for each iteration of the model fitting procedure. No
intermediate output will be printed if TRUE. Defaults to FALSE.}

\item{verbose}{If TRUE, the estimated theta/beta parameters will be printed
for each iteration of the model fitting procedure. Defaults to FALSE.
Ignored if quiet is TRUE.}

\item{optim.method}{Optimization method to be used for the maximum
likelihood estimation that is passed to optim. Defaults to "Nelder-Mead".
See \code{\link[stats]{optim}}.}

\item{optim.control}{Control parameter that is passed to optim. See
\code{\link[stats]{optim}}.}

\item{penalty}{The type of penalized regression to be used. Should be one
of "lasso", "relaxed", "MCP", or "SCAD". Note that "lasso" and "relaxed"
will fit the model using glmnet and "MCP" and "SCAD" will fit the model
using ncvreg. See \code{\link[glmnet]{glmnet}} or
\code{\link[ncvreg]{ncvreg}}. Defaults to "lasso".}

\item{alpha}{The elastic net mixing parameter. 'alpha=1' corresponds to
lasso (or SCAD/MCP) penalty; 'alpha=0' corresponds to ridge regression.
See \code{\link[glmnet]{glmnet}} or \code{\link[ncvreg]{ncvreg}}. Defaults
to 1.}

\item{family}{Family parameter for the glmnet or ncvreg model. Currently
only "gaussian" and "binomial" are supported. Defaults to "gaussian". See
\code{\link[glmnet]{glmnet}} or \code{\link[ncvreg]{ncvreg}}.}

\item{nfolds}{Number of cross-validation folds for cv.glmnet. Defaults to
10. See \code{\link[glmnet]{cv.glmnet}}.}

\item{foldid}{Optional vector of values between 1 and "nfolds" specifying
what fold each observation should be assigned to in the cv.glmnet
cross-validation. See \code{\link[glmnet]{cv.glmnet}} and
\code{\link[ncvreg]{cv.ncvreg}}.}

\item{parallel}{Should parallel "foreach" be used to speed up the model
fitting procedure where possible? Defaults to FALSE. Specifically,
parallelization will be used for imputation and fitting the cv.glmnet
object. See \code{\link[glmnet]{cv.glmnet}}. Note that this
only applies to glmnet models (where penalty="lasso" or
penalty="relaxed"). Models using ncvreg (where penalty="MCP" or
penalty="SCAD") require a cluster argument for parallelization (see below).}

\item{cluster}{A cluster for running cv.ncvreg in parallel. See
\code{\link[ncvreg]{cv.ncvreg}} and \code{\link[parallel]{makeCluster}}.
This must be specified to run cv.ncvreg in parallel. It is ignored for
glmnet models.}

\item{adaptive}{Should adaptive lasso be used? Defaults to FALSE. It is
ignored for SCAD and MCP models.}
}
\value{
A PrestoGPModel object with slots updated based on the results of
the model fitting procedure. See \code{\link{PrestoGPModel-class}} for
details.
}
\description{
This method fits a PrestoGP model given a set of locations and predictor
and outcome variables.
}
\details{
If common_scale is TRUE, multivariate models will use the Matern
cross-covariance function described in Apanasovich et al. (2012). This
model can only be used if each outcome has only a single scale parameter.
If common_scale is FALSE, each column of locs will be divded by the
corresponding element of scaling, and the cross-covariance will be computed
under the assumption that all scale parameters are equal to 1. For
univariate models, the Vecchia approximation will not be recomputed in
each iteration of the model fitting procedure if common_scale is TRUE,
but the parameter is otherwise ignored.
}
\examples{
data(soil)
soil <- soil[!is.na(soil[,5]),] # remove rows with NA's
y <- soil[,4]                   # predict moisture content
X <- as.matrix(soil[,5:9])
locs <- as.matrix(soil[,1:2])

# Vecchia model
soil.vm <- new("VecchiaModel", n_neighbors = 10)
soil.vm <- prestogp_fit(soil.vm, y, X, locs)

# Impute missing y's
miss <- sample(1:nrow(soil), 20)
y.miss <- y
y.miss[miss] <- NA
soil.vm2 <- new("VecchiaModel", n_neighbors = 10)
soil.vm2 <- prestogp_fit(soil.vm, y, X, locs, impute.y = TRUE)

# Impute y's missing due to limit of detection
soil.lod <- quantile(y, 0.1)
y.lod <- y
y.lod[y.lod <= soil.lod] <- NA
soil.vm3 <- new("VecchiaModel", n_neighbors = 10)
soil.vm3 <- prestogp_fit(soil.vm, y, X, locs, impute.y = TRUE, lod = soil.lod)

# Full model
soil.fm <- new("FullModel")
soil.fm <- prestogp_fit(soil.fm, y, X, locs)

# Multivariate model
ym <- list()
ym[[1]] <- soil[,5]             # predict two nitrogen concentration levels
ym[[2]] <- soil[,7]
Xm <- list()
Xm[[1]] <- Xm[[2]] <- as.matrix(soil[,c(4,6,8,9)])
locsm <- list()
locsm[[1]] <- locsm[[2]] <- locs

soil.mvm <-  new("MultivariateVecchiaModel", n_neighbors = 10)
soil.mvm <- prestogp_fit(soil.mvm, ym, Xm, locsm)

# Space/elevation model
data(soil250, package="geoR")
y2 <- soil250[,7]               # predict pH level
X2 <- as.matrix(soil250[,c(4:6,8:22)])
# columns 1+2 are location coordinates; column 3 is elevation
locs2 <- as.matrix(soil250[,1:3])

soil.vm2 <- new("VecchiaModel", n_neighbors = 10)
# fit separate scale parameters for location and elevation
soil.vm2 <- prestogp_fit(soil.vm2, y2, X2, locs2, scaling = c(1, 1, 2))
}
\references{
\itemize{
\item Apanasovich, T.V., Genton, M.G. and Sun, Y. "A valid MatÃ©rn class of
cross-covariance functions for multivariate random fields with any number
of components", Journal of the American Statistical Association (2012)
107(497):180-193.
\item Messier, K.P. and Katzfuss, M. "Scalable penalized spatiotemporal
land-use regression for ground-level nitrogen dioxide", The Annals of
Applied Statistics (2021) 15(2):688-710.
\item Zou, H. "The adaptive lasso and its oracle properties", Journal of
the American Statistical Association (2006) 101(476):1418-1429.
}
}
\seealso{
\code{\link{PrestoGPModel-class}}, \code{\link[glmnet]{glmnet}}
}
